# Vector
Below highlights some of the key points learnt while developing `vector` as well as reasoning behind the design choices.

# `Vector<bool>` class specialization
As a boolean only requires 1 bit to handle its states, it is wasteful for vector to use any data type (e.g `int`, `char`, etc.) as the extra memory allocated is not used. Hence, in order to reduce memory usage, we would create a partial template specialization for the `vector<bool>` so as to ensure that each boolean only utilizes one bit.

<<<<<<< HEAD
# `Vector` Internal Implementation
My initial implementation consisted of a pointer to the allocated block, as well as two variables to keep track of the size and capacity. However, I noted that modern STL libraries implemented it differently, by utilizing 3 pointers instead to keep track of start, end, and end of the allocated block. Why you may ask? It is because the size of size_t usually corresponds to the size of a pointer. Hence, either implementation would still take up the same amount of space of 24 bytes. However, one thing to note is a slight optimization when it comes to using `end()`. By using pointers, we can avoid doing pointer arithmetic when calling `end()`. While this may seem trivial, especially when it results in us still having to do arithmetic for `size()` and `capacity()`, it is a slight optimization due to the frequent use of `end()` over `size()` and `capacity()`, especially when dealing with algorithms and ranges. Hence, I decided to follow this slight optimization trick and implemented the `vector` class using 3 pointers as well.

`Copy Assignment Operator`
My initial implementation of the the copy assignment operator was to create an entirely new copy of the array. However, I soon realized that it was inefficient, especially if the vector to be copied is of smaller capacity! In that case, I can simply copy the elements over without having to reallocate memory, and remove the extra elements. Another issue was to guarantee strong exception safety. What GCC does is that it allocates a temporary buffer with the allocator, and use an uninitialized copy to construct elements in new memory. On the other hand, Clang utilizes a `unique_ptr` approach to provide this guarantee. Since my implementation does not utilize allocators (for now), I will utilize `unique_ptr` to utilize RAII and ensure that no memory leaks occur.
=======
# `Vector` Copy Constructor
When implementing the copy constructor of `vector`, I found myself stuck on whether to make the new `vector` object's capacity the same as the capacity of the `vector` object that is passed. C++ states that the capacity must be at least enough to hold all the elements, but whether it is bigger is implementation-defined. Hence, my decision was to make it such that the capacity of the new `vector` object is just enough to hold all the elements. My reason for doing so was mainly to optimize space usage. However, this may prove to be detrimental to performance, especially if we were to add elements thereafter, which would immediately cause resizing to occur. However, I believe that there are workarounds to this, such as reserving the vector's capacity prior to copying. Hence, I would still stick to my decision of initializing the `vector` object's capacity to be the same as its size. (If anyone has any better suggestions do let me know!)
&nbsp;
Additionally, in order to optimize for storing trivial types, I utilize `memcpy` instead of using a for loop for copying elements. This makes it much faster as no constructor calls are required for initializing the elements. 
>>>>>>> 6aeb8495fd8e122887e64b87a9aaa40aa603ddd3
